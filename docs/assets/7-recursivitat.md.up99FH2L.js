import{_ as s,c as a,o as e,a4 as t}from"./chunks/framework.hPoXimdX.js";const u=JSON.parse('{"title":"7. Recursivitat","description":"","frontmatter":{},"headers":[],"relativePath":"7-recursivitat.md","filePath":"7-recursivitat.md"}'),n={name:"7-recursivitat.md"};function l(r,i,p,h,k,d){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="_7-recursivitat" tabindex="-1">7. Recursivitat <a class="header-anchor" href="#_7-recursivitat" aria-label="Permalink to &quot;7. Recursivitat&quot;">​</a></h1><p>La recursivitat és la capacitat d&#39;una funció o mètode per a cridar-se a si mateixa. Això permet dividir un problema gran en problemes més xicotets similars i resoldre&#39;ls directament.</p><h2 id="_7-1-la-recursivitat-requereix-sempre" tabindex="-1">7.1. La recursivitat requereix sempre: <a class="header-anchor" href="#_7-1-la-recursivitat-requereix-sempre" aria-label="Permalink to &quot;7.1. La recursivitat requereix sempre:&quot;">​</a></h2><ul><li><strong>Cas base</strong>: Cas més simple que es pot resoldre directament i permet parar les recursions.</li><li><strong>Casos recursius</strong>: Cridaes a si mateixa per a reduir el problema en una instància més menuda i simple.</li></ul><h2 id="_7-2-tipus-de-recursivitat" tabindex="-1">7.2. Tipus de recursivitat: <a class="header-anchor" href="#_7-2-tipus-de-recursivitat" aria-label="Permalink to &quot;7.2. Tipus de recursivitat:&quot;">​</a></h2><ul><li><strong>Recursivitat directa</strong>: Una funció es crida directament a si mateixa.</li><li><strong>Recursivitat indirecta</strong>: Una funció crida a una altra que al seu torn crida a la primera. Es produeix un cicle cridaes recursives entre ambdues.</li><li><strong>Recursivitat lineal</strong>: Cada cridada recursiva es fa sobre un subproblema diferent. Per exemple, en recórrer un arbre binari.</li><li><strong>Recursivitat en cua</strong>: La cridada recursiva és l&#39;última instrucció de la funció. Això permet optimitzar l&#39;ús de la pila.</li></ul><h2 id="_7-3-avantatges" tabindex="-1">7.3. Avantatges: <a class="header-anchor" href="#_7-3-avantatges" aria-label="Permalink to &quot;7.3. Avantatges:&quot;">​</a></h2><ul><li>Simplicitat conceptual i llegibilitat en alguns casos.</li><li>Permet resoldre problemes que es divideixen fàcilment en subproblemes.</li></ul><h2 id="_7-4-desventajas" tabindex="-1">7.4. Desventajas: <a class="header-anchor" href="#_7-4-desventajas" aria-label="Permalink to &quot;7.4. Desventajas:&quot;">​</a></h2><ul><li>Major ús de memòria per acumulació de cridaes.</li><li>Risc de desbordament de pila (StackOverflowError).</li></ul><h2 id="_7-5-recursivitat-vs-iteracio" tabindex="-1">7.5. Recursivitat vs iteració <a class="header-anchor" href="#_7-5-recursivitat-vs-iteracio" aria-label="Permalink to &quot;7.5. Recursivitat vs iteració&quot;">​</a></h2><p>La recursivitat i la iteració (usant bucles com while o for) són dues formes diferents de resoldre el mateix problema.</p><h3 id="_7-5-1-exemple-suma-dels-numeros-de-l-1-al-n" tabindex="-1">7.5.1. Exemple: Suma dels números de l&#39;1 al n <a class="header-anchor" href="#_7-5-1-exemple-suma-dels-numeros-de-l-1-al-n" aria-label="Permalink to &quot;7.5.1. Exemple: Suma dels números de l&#39;1 al n&quot;">​</a></h3><p><strong>Solució iterativa utilitzant un bucle for:</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> suma</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> suma </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    suma </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> suma; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>Solución recursiva:</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> suma</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> suma</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>Anàlisi de les diferències:</strong></p><ul><li>La versió iterativa utilitza un bucle i una variable acumuladora (suma) per a anar guardant el resultat parcial.</li><li>La versió recursiva es basa en la descomposició del problema en problemes més xicotets, fins a arribar a un cas base senzill de resoldre (quan n és 1).</li><li>La recursivitat pot ser més elegant i fàcil d&#39;entendre, però consumeix més recursos ja que es van acumulant anomenades en la pila.</li><li>La iteració sol ser més eficient quant a ús de memòria i velocitat d&#39;execució.</li></ul>`,19)]))}const o=s(n,[["render",l]]);export{u as __pageData,o as default};
